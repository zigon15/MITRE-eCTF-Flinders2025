"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""

import asyncio
from asyncio import Event, Queue, Lock
from dataclasses import dataclass
from collections import namedtuple
import json
import time

from loguru import logger

from ectf25.utils import Encoder


Frame = namedtuple("Frame", ["channel", "data", "timestamp"])


@dataclass
class Channel:
    number: int
    fps: float
    frames: list[Frame]

    def __post_init__(self):
        self.send_frame = Event()

    async def frame_clock(self):
        """Triggers the send_frame Event every time a frame should be sent"""
        sleep = 1 / self.fps
        try:
            while True:
                if self.send_frame.is_set():
                    logger.warning(
                        f"Channel {self.number} not meeting FPS requirement!"
                    )
                self.send_frame.set()
                await asyncio.sleep(sleep)
        finally:
            logger.critical(f"{self} frame clock crashed!")

    @classmethod
    def from_parser(cls, arg: str) -> "Channel":
        """Parses the --channel argparse argument into a Channel"""
        number, fps, frame_file = arg.split(":")
        try:
            with open(frame_file, "rb") as f:
                frames = json.load(f)

        except (FileNotFoundError, json.JSONDecodeError):
            logger.exception(f"Frame file {frame_file} bad!")
            raise
        if not isinstance(frames, list) or not all(
            isinstance(frame, list) for frame in frames
        ):
            logger.critical(f"{frame_file} is not a valid file!")
            raise ValueError()

        # convert frame from list to named tuple
        for i, frame in enumerate(frames):
            # Each frame is a list of [channel, data, timestamp]
            # See examples in frames/ for what this layout should look like
            frames[i] = Frame(
                frame[0], frame[1], frame[2]  # channel  # data  # timestamp
            )

        return cls(int(number), int(fps), frames)


LOW_PRIORITY = 1
HIGH_PRIORITY = 2


class Uplink:
    """Robust Uplink class to serve encoded frames to the Satellite for the full
    end-to-end setup

    You can use ectf25.utils.tester for a lighter-weight development setup
    """

    def __init__(self, secrets: bytes, channels: list[Channel], host: str, port: int):
        """
        :param secrets: Contents of the secrets file generated by
            ectf25_design.gen_secrets
        :param channels: List of Channels to serve
        :param host: TCP host to serve frames on (use localhost for local setup)
        :param port: TCP port to serve frames on
        """
        self.secrets = secrets
        self.host = host
        self.port = port
        self.channels = channels
        self.encoder = Encoder(self.secrets)
        self.encoded_queue = Queue()
        self.uplink_down = Event()
        self.uplink_down.set()
        self.read_lock = Lock()

    async def uplink_drain(self):
        """Drain uplink if satellite not connected"""
        while True:
            # wait for uplink to come down
            await self.uplink_down.wait()

            # throw away a line
            async with self.read_lock:
                await self.encoded_queue.get()

    async def handle_uplink(self, _, writer: asyncio.StreamWriter):
        """Serve the uplink to the satellite"""
        # mark uplink as up
        self.uplink_down.clear()
        try:
            # serve frames from encoder to uplink until connection crashes
            while True:
                async with self.read_lock:
                    frame = await self.encoded_queue.get()
                writer.write(f"{frame}\n".encode())
                await writer.drain()
        except (ConnectionResetError, json.JSONDecodeError):
            # gracefully handle satellite crashing
            pass
        finally:
            self.uplink_down.set()
            logger.critical("Uplink unexpectedly closed!")

    async def uplink(self):
        """Run the uplink server"""
        logger.info("Starting uplink server")
        server = await asyncio.start_server(self.handle_uplink, self.host, self.port)
        try:
            await asyncio.create_task(self.uplink_drain())
            async with server:
                logger.info(f"Serving uplink channel at {(self.host, self.port)}")
                await asyncio.create_task(server.serve_forever())
        finally:
            logger.critical("Uplink server ended unexpectedly!")

    async def frame_stream(self, channel: Channel):
        """Encode a frame for each Channel.send_frame event into the encoded queue"""
        logger.info(
            f"Starting frame stream for channel {channel.number} @ {channel.fps} fps"
        )
        idx = 0
        ln = len(channel.frames)
        try:
            while True:
                await channel.send_frame.wait()
                channel.send_frame.clear()
                timestamp = int(time.time_ns() / 1000)
                frame = channel.frames[idx % ln].data.encode()
                encoded = self.encoder.encode(channel.number, frame, timestamp)
                packaged_frame = json.dumps(
                    {
                        "channel": channel.number,
                        "timestamp": timestamp,
                        "encoded": encoded.hex(),
                    }
                )
                self.encoded_queue.put_nowait(packaged_frame)
                idx += 1
        except Exception as e:
            logger.critical(f"Frame stream failed for {channel}")
            raise e

    async def serve(self):
        """Serve the uplink forever"""

        # Spin up all tasks
        async with asyncio.TaskGroup() as tg:
            tg.create_task(self.uplink())
            for channel in self.channels:
                tg.create_task(self.frame_stream(channel))
                tg.create_task(channel.frame_clock())

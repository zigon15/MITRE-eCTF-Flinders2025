
"""
Author: Simon Rosenzweig
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""

import struct
from loguru import logger

SUBSCRIPTION_KDF_KEY_LEN = 32
SUBSCRIPTION_CIPHER_AUTH_TAG_LEN = 16
FRAME_KDF_KEY_LEN = 32
FLASH_KDF_KEY_LEN = 32
FLASH_KDF_KEY_INPUT_LEN = 32
CHANNEL_NUM_LEN = 2
CHANNEL_LEN = 4
CHANNEL_KEY_LEN = 32

class GlobalSecrets:
    def __init__(self, raw_secrets: bytes):
        self.secrets = self.parse_secrets(raw_secrets)
        # logger.info(f"@INFO Global Secrets -> {self.secrets}")

    def parse_secrets(
        self, raw_secrets: bytes,   
    ) -> list[dict[int, str]]: 
        """Parse the binary secrets file

        Returns a dictionary of the channels and channel keys for this deployment

        :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
        """
        offset = 0

        # logger.info(f"@INFO Parsing Global Secrets -> Raw Secrets: {raw_secrets}, Length: {len(raw_secrets)}")

        # [0:31] bytes are subscription KDF key
        subscription_kdf_key = raw_secrets[offset:offset+SUBSCRIPTION_KDF_KEY_LEN] 
        offset += SUBSCRIPTION_KDF_KEY_LEN

        # [32:47]
        subscription_cipher_auth_tag = raw_secrets[offset:offset+SUBSCRIPTION_CIPHER_AUTH_TAG_LEN] 
        offset += SUBSCRIPTION_CIPHER_AUTH_TAG_LEN

        # [48:79] bytes are frame KDF key
        frame_kdf_key = raw_secrets[offset:offset+FRAME_KDF_KEY_LEN]
        offset += FRAME_KDF_KEY_LEN
        
        # [80:111] bytes are flash KDF key
        flash_kdf_key = raw_secrets[offset:offset+FLASH_KDF_KEY_LEN]
        offset += FLASH_KDF_KEY_LEN

        # [112:143] bytes are flash KDF input key
        flash_kdf_input_key = raw_secrets[offset:offset+FLASH_KDF_KEY_INPUT_LEN]
        offset += FLASH_KDF_KEY_INPUT_LEN

        # [144:145] bytes are number of channels (16b) followed by channel IDs (32b each)
        num_channels = struct.unpack('<H', raw_secrets[offset:offset+CHANNEL_NUM_LEN])[0]
        offset += CHANNEL_NUM_LEN

        channels = [
            struct.unpack('<I', raw_secrets[offset + i*CHANNEL_LEN: offset + (i+1)*CHANNEL_LEN])[0]
            for i in range(num_channels)
        ]
        offset += num_channels*CHANNEL_LEN

        # Remaining bytes are the 256-bit channel keys
        channel_keys = [
            raw_secrets[offset + i*CHANNEL_KEY_LEN : offset + (i+1)*CHANNEL_KEY_LEN]
            for i in range(num_channels)
        ]

        # print(', '.join(f'0x{b:02X}' for b in subscription_kdf_key))

        # for channel_key, channel in zip(channel_keys, channels):
        #     print(channel)
        #     print(', '.join(f'0x{b:02X}' for b in channel_key))
        
        # Print secrets for debugging
        # channel_key_pairs = [
        #     f"{{Channel: {channel}, Key: 0x{key.hex()}}}'" 
        #     for channel, key in zip(channels, channel_keys)
        # ]
        # logger.info(
        #     f"Secrets: {{"
        #         f"Subscription KDF Key: 0x{subscription_kdf_key.hex()}', "  
        #         f"Subscription Cipher Auth Tag: 0x{subscription_cipher_auth_tag.hex()}, "
        #         f"Frame KDF Key: {frame_kdf_key.hex()}', "  
        #         f"Channel Secrets: [{', '.join(channel_key_pairs)}]"
        #     f"}}"
        # )

        return {
            "SubscriptionKdfKey": subscription_kdf_key,
            "SubscriptionCipherAuthTag": subscription_cipher_auth_tag,
            "FrameKdfKey": frame_kdf_key,
            "ChannelSecrets": [{"channel": channel, "key": key} for channel, key in zip(channels, channel_keys)]
        }
    
    def subscription_kdf_key(self):
        """
        Returns the subscription KDF key
        """
        return self.secrets["SubscriptionKdfKey"]
    
    def subscription_cipher_auth_tag(self):
        """
        Returns the subscription cipher auth tag
        """
        return self.secrets["SubscriptionCipherAuthTag"]
    

    def frame_kdf_key(self):
        """
        Returns the frame KDF key
        """
        return self.secrets["FrameKdfKey"]
    
    def channel_key(
        self, channel: int
    ) -> str:
        """
        Returns the key for a given channel from the secrets

        :return: Channel key if channel found, else None
        """

        channel_key_pairs = self.secrets["ChannelSecrets"]

        # Search for the dictionary with the matching channel and return its key
        for pair in channel_key_pairs:
            if pair['channel'] == channel:
                return pair['key']
            
        return None
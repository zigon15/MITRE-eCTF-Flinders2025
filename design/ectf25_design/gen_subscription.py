"""
Author: Ben Janis
Date: 2025

This source file is part of an example system for MITRE's 2025 Embedded System CTF
(eCTF). This code is being provided only for educational purposes for the 2025 MITRE
eCTF competition, and may not meet MITRE standards for quality. Use this code at your
own risk!

Copyright: Copyright (c) 2025 The MITRE Corporation
"""

import argparse
import base64
from pathlib import Path
import struct
from cryptography.hazmat.primitives.cmac import CMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend

from loguru import logger

# Length of each AES key in bits and bytes notation
AES_KEY_LEN_BIT = 256
AES_KEY_LEN_BYTE = AES_KEY_LEN_BIT//8

SUBSCRIPTION_UPDATE_DATA_LEN = 34

def parse_secrets(
    raw_secrets: bytes,   
) -> list[dict[int, str]]: 
    """Parse the binary secrets file

    Returns a dictionary of the channels and channel keys for this deployment

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    """
    offset = 0

    # [0:31] bytes are subscription KDF key
    subscription_kdf_key = raw_secrets[0:32] 
    offset += 32

    # [32:63] bytes are frame KDF key
    frame_kdf_key = raw_secrets[offset:offset+32]
    offset += 32

    # [64:65] bytes are number of channels (16b) followed by channel IDs (16b each)
    num_channels = struct.unpack('<H', raw_secrets[offset:offset+2])[0]
    offset += 2

    channels = [
        struct.unpack('<H', raw_secrets[offset + i*2: offset + (i+1)*2])[0]
        for i in range(num_channels)
    ]
    offset += num_channels*2

    # Remaining bytes are the 256-bit channel keys
    channel_keys = [
        raw_secrets[offset + i*32 : offset + (i+1)*32]
        for i in range(num_channels)
    ]

    # Print secrets for debugging
    channel_key_pairs = [
        f"{{Channel: {channel}, Key: '{base64.b64encode(key).decode('utf-8')}}}'" 
        for channel, key in zip(channels, channel_keys)
    ]
    logger.debug(
        f"Secrets: {{"
            f"Subscription KDF Key: '{base64.b64encode(subscription_kdf_key).decode('utf-8')}', "  
            f"Frame KDF Key: '{base64.b64encode(frame_kdf_key).decode('utf-8')}', "  
            f"Channel Secrets: [{', '.join(channel_key_pairs)}]"
        f"}}"
    )

    return {
        "SubscriptionKdfKey": subscription_kdf_key,
        "FrameKdfKey": frame_kdf_key,
        "ChannelSecrets": [{"channel": channel, "key": key} for channel, key in zip(channels, channel_keys)]
    }

def get_key_by_channel(
    channel: int, decoded_secrets: bytes
) -> str:
    """Retrieve the key for a given channel from the secrets
    """

    channel_key_pairs = decoded_secrets["ChannelSecrets"]

    # Search for the dictionary with the matching channel and return its key
    for pair in channel_key_pairs:
        if pair['channel'] == channel:
            return pair['key']
    return None

def subscription_kdf(
    device_id: int,
    channel: int, channel_key: bytes, subscription_kdf_key: bytes, 
    start: int, end: int
) -> bytes:
    """
    AES Key Derivation Function for subscription update encryption
    """

    # Validate that the number of channels fit in required range
    if len(subscription_kdf_key) != AES_KEY_LEN_BYTE:
        logger.error(f"Bad subscription kdf key length, Expected {AES_KEY_LEN_BYTE} bytes!!")
        exit()

    # Max one block for key derivation!!
    # - ECB does not tie neighboring blocks together!!
    cipher = Cipher(
        algorithms.AES(subscription_kdf_key), 
        modes.ECB(),
        backend=default_backend()
    )
    encryptor = cipher.encryptor()

    # Input data to derive key from
    # [0]: Channel Key (80b) -> Only using part of it as need total block length to be 32 bytes!!
    # [10]: Device ID (32b)
    # [14]: Time Stamp Start (64b)
    # [22]: Time Stamp End (64b)
    # [30]: Channel (16b)
    # 10 + 4 + 8 + 8 + 2 = 32 bytes long -> 1 AES256 block long
    input_bytes = channel_key[0:10] + device_id.to_bytes(4, byteorder='little') +\
        start.to_bytes(8, byteorder='little') + end.to_bytes(8, byteorder='little') +\
        channel.to_bytes(2, byteorder='little')

    # Ensure input bytes are one block length only for security!!
    if len(input_bytes) != AES_KEY_LEN_BYTE:
        logger.error("AES input bytes len must be one block len as no block chaining use!! Multiple blocks insecure with ECB!!")
        exit()

    # Perform AES encryption
    derived_key = encryptor.update(input_bytes) + encryptor.finalize()
    derived_key = derived_key[0:32]

    logger.debug(f"KDF -> Subscription Key: {base64.b64encode(derived_key)}")

    return derived_key

def gen_subscription(
    secrets: bytes, device_id: int, start: int, end: int, channel: int
) -> bytes:
    """Generate the contents of a subscription.

    The output of this will be passed to the Decoder using ectf25.tv.subscribe

    :param secrets: Contents of the secrets file generated by ectf25_design.gen_secrets
    :param device_id: Device ID of the Decoder
    :param start: First timestamp the subscription is valid for
    :param end: Last timestamp the subscription is valid for
    :param channel: Channel to enable
    """

    # Please note that the secrets are READ ONLY at this stage!
    secrets = parse_secrets(secrets)

    # Load channel key
    channel_key = get_key_by_channel(channel, secrets)
    if channel_key == None:
        logger.error(f"Channel {channel} not found in deployment secrets!!")
        exit()

    # Derive subscription update key from all message parameters
    subscription_update_key = subscription_kdf(
        device_id=device_id,
        channel=channel, channel_key=channel_key,
        subscription_kdf_key=secrets["SubscriptionKdfKey"],
        start=start,
        end=end,
    )

    # Packet format
    # [0]: Packet length (8b)
    # [1]: Time Stamp Start (64b)
    # [9]: Time Stamp End (64b)
    # [17]: MIC (16 bytes)
    raw_data = struct.pack(
        "<BQQB", 
        17 + 16,
        start,
        end,
        channel,
    )

    c = CMAC(algorithms.AES(subscription_update_key), backend=default_backend())
    c.update(raw_data)
    mac = c.finalize()
    logger.debug(f"Message MAC: {base64.b64encode(mac)}")

    # Add on the MIC
    raw_data = raw_data + mac

    if len(raw_data) != SUBSCRIPTION_UPDATE_DATA_LEN:
        logger.error(f"Bad Subscription Update Length -> ({SUBSCRIPTION_UPDATE_DATA_LEN} != {len(raw_data)})!!")
        exit()

    # Subscription update will be sent to the decoder with ectf25.tv.subscribe
    return raw_data

def parse_args():
    """Define and parse the command line arguments

    NOTE: Your design must not change this function
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--force",
        "-f",
        action="store_true",
        help="Force creation of subscription file, overwriting existing file",
    )
    parser.add_argument(
        "secrets_file",
        type=argparse.FileType("rb"),
        help="Path to the secrets file created by ectf25_design.gen_secrets",
    )
    parser.add_argument("subscription_file", type=Path, help="Subscription output")
    parser.add_argument(
        "device_id", type=lambda x: int(x, 0), help="Device ID of the update recipient."
    )
    parser.add_argument(
        "start", type=lambda x: int(x, 0), help="Subscription start timestamp"
    )
    parser.add_argument("end", type=int, help="Subscription end timestamp")
    parser.add_argument("channel", type=int, help="Channel to subscribe to")
    return parser.parse_args()


def main():
    """Main function of gen_subscription

    You will likely not have to change this function
    """
    # Parse the command line arguments
    args = parse_args()

    subscription = gen_subscription(
        args.secrets_file.read(), args.device_id, args.start, args.end, args.channel
    )

    # Print the generated subscription for your own debugging
    # Attackers will NOT have access to the output of this (although they may have
    # subscriptions in certain scenarios), but feel free to remove
    #
    # NOTE: Printing sensitive data is generally not good security practice
    logger.debug(f"Generated subscription: {subscription}")

    # Open the file, erroring if the file exists unless the --force arg is provided
    with open(args.subscription_file, "wb" if args.force else "xb") as f:
        f.write(subscription)

    # For your own debugging. Feel free to remove
    logger.success(f"Wrote subscription to {str(args.subscription_file.absolute())}")


if __name__ == "__main__":
    main()
